---
title: "devlog #1 - Map improvements"
date: 2024-01-02
categories: [Pet Project]
tags: [bevy, devlog, ecs, roguelike, rust]
---

Welcome to the first *official* devlog post! You can still 
[read the previous devlog entry](https://boreec.github.io/posts/devlog-0000/) to
understand the project and the idea behind. In this entry, I'll mainly share
some map improvements I've been working on.

1. [Bug Fixing: Player spawning on a non-walkable tile](#bug-fixing-player-spawning-on-a-non-walkable-tile)
2. [Bug Fixing: Pixel artifacts between the tiles](#bug-fixing-pixel-artifacts-between-tiles)
3. [Mechanics/Systems: Creating the map procedurally](#mechanicssystem-creating-the-map-procedurally)
    1. [With a Cellular Automaton](#with-cellular-automaton)
    2. [With Perlin Noise](#with-perlin-noise)
4. [Closing Thoughts](#closing-thoughts)

## Bug Fixing: Player spawning on a non-walkable tile

Initially, the player was hardcoded to spawn at (0,0) regardless of the tile.
But, since the stones are randomly generated on the map, it can lead to
situations where the player spawns on a non-walkable tile.

```rust
fn spawn_player(mut commands: Commands, tileset: Res<TilesetMain>) {
    let map_position = MapPosition::new(0, 0); // hardcoded spawn :(
    let (sprite_x, sprite_y) = calculate_sprite_position(&map_position);
    commands.spawn(PlayerBundle {
        player: Player,
        position: map_position,
        sprite: SpriteSheetBundle {
            texture_atlas: tileset.0.clone(),
            transform: Transform::from_xyz(sprite_x, sprite_y, Z_INDEX_ACTOR),
            sprite: TextureAtlasSprite::new(SPRITE_IDX_PLAYER),
            ..Default::default()
        },
    });
}
```

{: style="text-align:center"}
![roguelike-6](/assets/img/blog/devlog/roguelike-0006.png)
*bug: Player spawning on a stone*

--- 

**Solution**: To fix this, the player's spawning position needs to be given by
the `Map`. It implies a the map being created before the player. To make sure
things are done in this order, I decided I split the previous
`GameState::Initializing` state in two:

```rust
#[derive(Debug, Clone, Copy, Default, Eq, PartialEq, Hash, States)]
pub enum GameState {
    #[default]
    Uninitialized,
    InitializingMap,
    InitializingPlayer,
    PlayerTurn,
    EnemyTurn,
}
```

```rust
    .add_systems(OnEnter(GameState::InitializingMap), initialize_map)
    .add_systems(OnEnter(GameState::InitializingPlayer), initialize_player)
```

When initializing the player, its spawn position is given by a method
implemented via the `Map` (now taken as a parameter):

```rust
pub fn generate_random_spawning_position(&self) -> MapPosition {
    let spawnable_positions: Vec<_> = self
        .tiles
        .iter()
        .enumerate()
        .filter(|(_, tile)| tile.is_walkable())
        .map(|(index, _)| index)
        .collect();

    if spawnable_positions.is_empty() {
        panic!("There are no spawnable positions");
    }

    let mut rng = rand::thread_rng();
    let index = *spawnable_positions.choose(&mut rng).unwrap();

    MapPosition::new(index % self.width, index / self.height)
}
```

```rust
fn initialize_player(
    mut commands: Commands,
    mut game_next_state: ResMut<NextState<GameState>>,
    query_map: Query<&Map>,
    tileset: Res<TilesetMain>,
) {
    let map = query_map.single();
    let map_position = map.generate_random_spawning_position();
    let (sprite_x, sprite_y) = calculate_sprite_position(&map_position);
    commands.spawn(PlayerBundle {
        player: Player,
        position: map_position,
        sprite: SpriteSheetBundle {
            texture_atlas: tileset.0.clone(),
            transform: Transform::from_xyz(sprite_x, sprite_y, Z_INDEX_ACTOR),
            sprite: TextureAtlasSprite::new(SPRITE_IDX_PLAYER),
            ..Default::default()
        },
    });
    game_next_state.set(GameState::PlayerTurn);
}
```

{: style="text-align:center"}
![roguelike-7](/assets/img/blog/devlog/roguelike-0007.png)
*Player spawning on a random walkable tile*

## Bug Fixing: Pixel artifacts between tiles

There's an issue I had and that have been bothering me recently. It's related
to the way tiles are displayed on screen. If you pay close attention to the
following image, you'll notice vertical pixel artifacts between the tiles.

{: style="text-align:center"}
![roguelike-8](/assets/img/blog/devlog/roguelike-0008.png)
*Pixel artifacts between the tiles*

**Solution**: It seems to be [a known issue](https://github.com/bevyengine/bevy/issues/3593) related to Bevy's [MSAA](https://docs.rs/bevy/latest/bevy/prelude/enum.Msaa.html).
After turning it off with `insert_resource(Msaa::Off)`, the pixel artifacts were gone. &#128513;

{: style="text-align:center"}
![roguelike-9](/assets/img/blog/devlog/roguelike-0009.png)
*No pixel artifacts anymore*


## Mechanics/System: Creating the map procedurally

With these issues fixed, I could focus on something more interesting: generating
the map procedurally. Naively, one could think that putting rocks randomly on the
map is enough, but in order to provide a better playability, we need to take
into account a couple of criteria:

1. Harmony: Using a total random placement feels heavily artificial.
It's more enjoyable to walk in a terrain that looks somewhat natural or following
a certain pattern.
2. Walkable path: In its simplest form, the path from the beginning to the end
of a level must be walkable. It means that a player should never spawn trapped
between rocks.

I haven't decided yet what type of goal I want to put in the level, so I decided
to focus on the first criteria for the moment. To generate the map procedurally,
I decided to explore using **Cellular Automaton** and **Perlin Noise**.

### With Cellular Automaton

I never thought using [Cellular Automaton](https://en.wikipedia.org/wiki/Cellular_automaton)
was relevant when generating a 2D map until I stumbled upon these two blog posts:

1. [Procedural Generation with Cellular Automata](https://bronsonzgeb.com/index.php/2022/01/30/procedural-generation-with-cellular-automata/), by Bronson Zgeb
2. [Procedural Level Generation in Games using a Cellular Automaton](https://www.kodeco.com/2425-procedural-level-generation-in-games-using-a-cellular-automaton-part-1?page=1), by Kim Pedersen

It was a quite exciting finding as I am a cellular automaton enthusiast myself.
I wrote several [Game Of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)
implementations in the past, and last year I even did my own [Brian's Brain](https://github.com/boreec/Brian-s-Brain)
with Vulkan and Rust.

Here's the process I took for creating my cellular automaton:

1. Define a struct representing a cellular automaton and an enum representing
the cellular states:
    ```rust
    #[derive(Clone, PartialEq, Eq)]
    pub enum CellularState {
        Alive,
        Dead,
    }

    pub struct CellularAutomaton {
        pub width: usize,
        pub height: usize,
        pub cells: Vec<CellularState>,
    } 
    ```
2. Initialize the cellular automaton with random alive cells:
    ```rust
    impl CellularAutomaton {
        pub fn new(width: usize, height: usize, alive_probability: f64) -> Self {
            let mut cells: Vec<CellularState> = Vec::<CellularState>::new();
            let mut rng = rand::thread_rng();
            for i in 0..(width * height) {
                if rng.gen_bool(alive_probability) {
                    cells.push(CellularState::Dead);
                } else {
                    cells.push(CellularState::Alive);
                }
            }

            Self {
                width,
                height,
                cells,
            }
        }
    }
    ```


So, I created my a very basic implementation of a cellular automaton and I implemented
the `from` trait on my `Map` (see [related commit](https://github.com/boreec/roguelike/tree/3136b5be24f507a5962e39719a67ee16e2681bef)):

```rust
impl From<CellularAutomaton> for Map {
    fn from(ca: CellularAutomaton) -> Self {
        Self {
            width: ca.width,
            height: ca.height,
            tiles: ca
                .cells
                .iter()
                .map(|cellular_state| match cellular_state {
                    CellularState::Alive => TileType::GrassWithStone,
                    CellularState::Dead => TileType::Grass,
                })
                .collect(),
        }
    }
}
```

```rust
fn initialize_map(
    mut commands: Commands,
    mut game_next_state: ResMut<NextState<GameState>>,
    tileset: Res<TilesetMain>,
) {
    let mut ca = CellularAutomaton::new(MAP_WIDTH, MAP_HEIGHT, true);
    for _ in 0..50 {
        ca.transition();
    }
    let m = Map::from(ca);

    for (i, tile) in m.tiles.iter().enumerate() {
        let tile_position = MapPosition {
            x: i % m.width,
            y: i / m.width,
        };
        let (sprite_x, sprite_y) = calculate_sprite_position(&tile_position);
        commands.spawn(TileBundle {
            tile: Tile,
            r#type: tile.clone(),
            position: tile_position,
            sprite: SpriteSheetBundle {
                transform: Transform::from_xyz(
                    sprite_x,
                    sprite_y,
                    Z_INDEX_TILE,
                ),
                sprite: TextureAtlasSprite::new(TileType::to_sprite_idx(&tile)),
                texture_atlas: tileset.0.clone(),
                ..Default::default()
            },
        });
    }
```

The idea is that a cellular automaton is built with the same size as the map
with random cell states. After a given number of transitions, it's converted
into a `Map`.

{: style="text-align:center"}
![roguelike-10](/assets/img/blog/devlog/roguelike-0010.png)
*Map generated initially with random 50% and 50 steps of Game of Life*

I tried to *smooth* the end result i.e. every empty tile is set as a rock is it
has more than 3 rock neighbours.

{: style="text-align:center"}
![roguelike-11](/assets/img/blog/devlog/roguelike-0011.png)
*Smoothing the end result*

### with Perlin Noise

## Closing Thoughts

As always, if you have any suggestions/remarks regarding the devlog content, the
code or anything else, please reach out! Don't hesitate to drop a &#11088; on the [project's page](https://github.com/roguelike).
This has the immediate effect to stop me from procrastinating.
